class Solution:
    '''
    #暴力解法
    def longestValidParentheses(self, s: str):
        res = 0
        for i in range(1, len(s) + 1):
            for j in range(i):
                if self.isValid(s[j:i]):
                    res = max(res, i - j)
        return res


    def isValid(self, s):
        stack = list()
        for c in s:
            if c == '(':
                stack.append(c)
            elif len(stack) > 0:
                stack.pop()
            else:
                return False
        return len(stack) == 0

    '''
    def longestValidParentheses(self, s: str):
        res = 0
        stack = list()
        for i in range(len(s)):
            if s[i] == '(':
                stack.append(i)
            elif len(stack) > 0 and s[stack[-1]] == '(':
                stack.pop()
            else:
                stack.append(i)
        if len(stack) == 0:
            return len(s)

        res = 0
        end = len(s)
        while stack:
            start = stack[-1]
            res = max(res, end - start - 1)
            end = start
            stack.pop()
        return max(res, end + 1)



if __name__ == '__main__':
    sol=Solution()
    s = "())()()(())((()(()()(((()))((((())((()(())()())(()((((()))()(()))(())()(())(()(((((())((((((()())())(()(()((())()))(()))))))()(()))((((())()()()))()()()(((()(()())(()()(()(()()(((()))))))()()))())())((()()))))))((()))(((()((())()(()()))((())))()()())))))))()))))(()))))()))()))()((())))((()))(()))))))(((()))))))))()(()()()(())((())()))()()(())))()()))(()())()))(((()())()))((())((((()))(()(()(()()()(((())()(((((()))((()(((((())(()()))((((((((()(()(()(()(())))(())(()())())(()((((()(())((()(())))(())))()(((((()(()()(())))))))())(())(())(()()(((())))((()))(((((()))))())))()((()))()))))())))))((())(((((()()))((((())))(((()(()(())())(((()(()(()()()())))())()))((()((())())()()()(((())(((((()((((((()((()())))((((())((()(((((((()(()((()()()(()(()())(()(()()((((())))()(((()())))(()()))()(()()()()(((((())(()))))((()))())))()((((((()))())))()(()))(())))((((()())(((((()()())(((((())(()())(()))))()(()()))()))))))())))(((())(()(()()))(()))()(((())))())((((()(((()))))))()(()(()))()()(()()))))))))((()))))))(())((()((()))()))((((((()())))))(()((())((((()))))(()(()()()()(()))()()(()(()))(()()(((((((()())(())(()())((())())()(()())((())()())())(()())))())))(())())())(())((()())(((()()))()))()()))()(()(())((((((((())))()((())((()((((((((((()))))(()(((((())(()(()())())))((())())))))()))(()((()()))((()((())()()()((()(())())((())())(()()(((())))))())()()(()))()())(()(()((())))((((()()(())))())(())(()(()(())())())(()()())()(())())))(()()(((())))((()()(((())()()(()())((((()()(()())(()((((()(()()(()(()(((()((()())(()()))(()((((()(((((()))))()()))(((()((((((()(()()()()())()))(()(())))))((()(((()())())))(((()()))(()(()(((((((()()))(()(())))())()(())())(())(()))(())(()))()()(()()())))))()))()((())(((()((((((((())()()))())))((()())("
    print(sol.longestValidParentheses(s))

    '''
    总金额：n
    纸币面额：a,b,c,d...
    纸币总数不可超过limit
    求不超过总金额的纸币兑换组合，使得基于此组合可支付的不同金额最多
    '''